import { Inject, Injectable, Optional } from '@nestjs/common';
import { BaseCrudService } from '@shared/abstractions/service.base';
import { BadRequestError } from '@shared/errors/domain-error';
import { MODULE_IDENTIFIER } from '@shared/tokens/common.token';
import { UUID } from '@shared/types/general.type';
import { UserEntity } from '@user/adapters/repository/user.entity';
import { hash } from 'bcryptjs';
import { v7 } from 'uuid';
import {
    UserCreateDto,
    UserCreateSchema,
    UserLoginDto,
    UserRegisterDto,
    UserSearchDto,
    UserSearchSchema,
    UserUpdateDto,
    UserUpdateSchema,
} from '../model/user.dto';
import { ERR_USER_EMAIL_EXISTS } from '../model/user.error';
import { User } from '../model/user.model';
import { USER_CONFIG_TOKEN, USER_REPOSITORY_TOKEN } from '../model/user.token';
import { IUserConfig } from '../ports/user-config.interface';
import { IUserRepository } from '../ports/user-repository.interface';
import { IUserService } from '../ports/user-service.interface';

@Injectable()
export class UserService
    extends BaseCrudService<User, UserCreateDto, UserUpdateDto, UserSearchDto>
    implements IUserService
{
    protected createSchema = UserCreateSchema;
    protected updateSchema = UserUpdateSchema;
    protected searchSchema = UserSearchSchema;

    test: UserEntity = new UserEntity();

    constructor(
        @Inject(USER_CONFIG_TOKEN) private config: IUserConfig,
        @Inject(USER_REPOSITORY_TOKEN) protected readonly repository: IUserRepository,
        @Optional() @Inject(MODULE_IDENTIFIER) protected readonly moduleName: string = '',
    ) {
        super(moduleName, repository);
    }

    verifyToken(token: string): Promise<any> {
        throw new Error('Method not implemented.');
    }

    login(payload: UserLoginDto): Promise<string> {
        throw new Error('Method not implemented.');
    }

    register(payload: UserRegisterDto): Promise<UUID> {
        throw new Error('Method not implemented.');

        // TODO: hash password
    }

    override async create(payload: UserCreateDto, hashedPassword?: string): Promise<UUID> {
        const { success, error, data } = this.createSchema.safeParse(payload);

        if (!success) {
            throw this.handleValidationError(error);
        }

        // Check if email already exists
        await this.validateCreate(payload);

        // Inside this function, we allow user to pass in credentials (in case of external registration)
        // Or credentials will be auto-generated by the service
        if (!hashedPassword) {
            hashedPassword = await this.hashPassword(this.config.getDefaultPassword());
        }

        const id = v7();
        const currentTimestamp = BigInt(Date.now());

        const entity = {
            id,
            ...data,
            password: hashedPassword,
            createdAt: currentTimestamp,
            updatedAt: currentTimestamp,
        };

        await this.repository.create(entity);

        return id;
    }

    protected async validateCreate(data: UserCreateDto): Promise<void> {
        const isEmailExist = await this.checkIfEmailExist(data.email);

        if (isEmailExist) {
            throw BadRequestError(ERR_USER_EMAIL_EXISTS.message);
        }
    }

    protected validateUpdate(id: string, data: UserUpdateDto): Promise<void> {
        throw new Error('Method not implemented.');
    }

    // Helper methods
    private async checkIfEmailExist(email: string): Promise<boolean> {
        if (!this.repository.findByConditions) throw new Error('Method not implemented.');
        return !!(await this.repository.findByConditions({ email }));
    }

    private async hashPassword(password: string): Promise<string> {
        return await hash(password, 10);
    }
}
